在接收到RPC的请求或回复时，如果RPC中参数的任期大于当前节点任期，无论当前节点处于什么状态，必须立刻变为跟随者
在接收到RPC的请求或回复时，如果要对当前节点进行操作，必须保证RPC中的参数的任期等于当前任期
当候选者发起投票时，LastLogIndex应该是当前日志的长度，而不是已提交的日志的长度
当领导者发送心跳（或AppendEntry）时，PrevLogIndex应该是之前领导者发送过去的日志的最后一条的索引，不是跟随者日志的长度，也不是领导者日志的长度。比如你把1至3的索引发送过去了，那下一次发送时PrevLogIndex应该赋值为3。
LastApplied代表你应用到本地的索引号，它永远小于等于CommitIndex
准确区别CommitIndex、PrevLogIndex、LastLogIndex、LeaderCommit、LastApplied
心跳和AppendEntry的唯一区别在于一个有日志一个没有日志，也就是说除了不能给跟随者增加日志外，心跳也一定需要完成日志一致性检测
投票和AppendEntry之前需要进行非常小心的检测，首先检查任期，然后检查日志
当两条日志的索引号和任期相同时，可以保证它们存储的是相同的日志
投票允许后才能重置选举超时时间，AppendEntry只有在接收到当前领导人时才能重置选举超时时间，也就是说发送过来的任期大于等于当前任期
领导者只能提交自己任期内的日志，但是它可以通过提交自己任期内的日志来间接提交之前任期的日志
6.824的Lab 2是一个很好的实现Raft的开始
Raft中的多线程编程是最基本的对于互斥量和条件变量的运用，不要被吓倒
把论文中的图2落实到每一个字

https://github.com/happyer/distributed-computing/tree/master/src/raft
